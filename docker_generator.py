"""
docker_generator.py — Dockerfile generation for DevReplicator
"""

from pathlib import Path
from typing import Optional
from detectors import ProjectInfo
from utils import log_info, log_warn


DOCKERFILE_NAME = "Dockerfile.devreplicator"


def generate_dockerfile(repo_path: str, info: ProjectInfo) -> str:
    """
    Write a Dockerfile into the cloned repo directory.
    Returns the absolute path to the generated Dockerfile.
    """
    root    = Path(repo_path)
    outpath = root / DOCKERFILE_NAME

    if info.project_type == "python":
        content = _python_dockerfile(info)
    elif info.project_type == "poetry":
        content = _poetry_dockerfile(info)
    elif info.project_type == "node":
        content = _node_dockerfile(info)
    elif info.project_type == "unknown":
        content = _unknown_dockerfile(info)
    else:
        raise ValueError(f"Unhandled project type: {info.project_type!r}")

    outpath.write_text(content)
    log_info(f"Dockerfile written → {outpath}")
    return str(outpath)


# ── Template builders ────────────────────────────────────────────────────────

def _python_dockerfile(info: ProjectInfo) -> str:
    entry     = info.entry_point or "main.py"
    dep_block = _pip_install_block(info)

    return f"""\
# Auto-generated by DevReplicator
FROM {info.base_image}

# System dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    git curl \\
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install dependencies before copying source (layer caching)
{dep_block}

# Copy project source
COPY . .

# Run application
CMD ["python", "{entry}"]
"""


def _pip_install_block(info: ProjectInfo) -> str:
    if info.dep_file == "requirements.txt":
        return (
            "COPY requirements.txt .\n"
            "RUN pip install --no-cache-dir --upgrade pip && \\\n"
            "    pip install --no-cache-dir -r requirements.txt"
        )

    if info.scanned_imports:
        pkgs = " ".join(sorted(info.scanned_imports))
        log_warn(f"Generating pip install from scanned imports: {pkgs}")
        return (
            f"# NOTE: Dependency file not found — installing scanned imports\n"
            f"RUN pip install --no-cache-dir --upgrade pip && \\\n"
            f"    pip install --no-cache-dir {pkgs}"
        )

    return (
        "# No requirements.txt found; skipping pip install.\n"
        "RUN pip install --no-cache-dir --upgrade pip"
    )


def _poetry_dockerfile(info: ProjectInfo) -> str:
    entry = info.entry_point or "main.py"
    return f"""\
# Auto-generated by DevReplicator
FROM {info.base_image}

RUN apt-get update && apt-get install -y --no-install-recommends \\
    git curl \\
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install --no-cache-dir poetry

WORKDIR /app

# Install dependencies (no venv inside Docker)
COPY pyproject.toml poetry.lock* ./
RUN poetry config virtualenvs.create false && \\
    poetry install --no-interaction --no-ansi

COPY . .

CMD ["python", "{entry}"]
"""


def _node_dockerfile(info: ProjectInfo) -> str:
    return f"""\
# Auto-generated by DevReplicator
FROM {info.base_image}

RUN apt-get update && apt-get install -y --no-install-recommends \\
    git curl \\
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install dependencies (layer caching)
COPY package.json package-lock.json* yarn.lock* ./
RUN if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \\
    else npm ci --prefer-offline 2>/dev/null || npm install; fi

COPY . .

CMD ["npm", "start"]
"""


def _unknown_dockerfile(info: ProjectInfo) -> str:
    base  = info.base_image or "ubuntu:22.04"
    start = info.start_command or "bash"
    return f"""\
# Auto-generated by DevReplicator (unknown project type)
FROM {base}

RUN apt-get update && apt-get install -y --no-install-recommends \\
    git curl build-essential \\
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY . .

CMD {_shell_cmd(start)}
"""


def _shell_cmd(cmd: str) -> str:
    parts = cmd.split()
    formatted = '", "'.join(parts)
    return f'["{formatted}"]'
